import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? ['https://studybuddy-ia.vercel.app', 'https://studybuddy-ia-git-main-fernandoludvig.vercel.app']
    : 'http://localhost:5173',
  credentials: true
}));
app.use(express.json());

// Endpoint de teste
app.get('/api/test', (req, res) => {
  res.json({ message: 'Servidor funcionando!' });
});

// Endpoint para gerar planos de estudo
app.post('/api/generate-study-plan', async (req, res) => {
  try {
    console.log('üì® Requisi√ß√£o de plano recebida:', req.body);
    const { subjects, subSubjects, examDate, hoursPerDay, difficulty, goal } = req.body;
    const ANTHROPIC_API_KEY = process.env.VITE_ANTHROPIC_API_KEY;

    console.log(`üîç Gerando plano para: ${subjects}`);
    console.log(`üîë API Key configurada: ${ANTHROPIC_API_KEY ? 'Sim' : 'N√£o'}`);

    if (!ANTHROPIC_API_KEY) {
      console.error('‚ùå API Key n√£o configurada');
      return res.status(500).json({ error: 'API Key n√£o configurada' });
    }

    // Calcula quantas semanas at√© a prova
    const examDateObj = new Date(examDate);
    const today = new Date();
    const timeDiff = examDateObj.getTime() - today.getTime();
    const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));
    const weeks = Math.max(1, Math.ceil(daysDiff / 7));

    const prompt = `Voc√™ √© um especialista em educa√ß√£o e planejamento de estudos. Crie um plano de estudos detalhado e personalizado.

DADOS DO ESTUDANTE:
- Mat√©rias: ${subjects}
${subSubjects ? `- Sub-mat√©rias/T√≥picos espec√≠ficos: ${subSubjects}` : ''}
- Data da prova: ${examDate} (${daysDiff} dias restantes)
- Horas dispon√≠veis por dia: ${hoursPerDay}h
- N√≠vel: ${difficulty}
- Objetivo: ${goal}
- Dura√ß√£o do plano: ${weeks} semanas

CRIE UM PLANO COM:
1. T√≠tulo criativo e motivador
2. Vis√£o geral do plano
3. Cronograma semanal detalhado com:
   - Dias da semana (Segunda a Domingo)
   - Mat√©rias para cada dia
   - T√≥picos espec√≠ficos para estudar (use as sub-mat√©rias quando fornecidas)
   - Horas de estudo por dia
   - T√≥picos marc√°veis como conclu√≠dos
4. Dicas personalizadas baseadas no objetivo

IMPORTANTE SOBRE SUB-MAT√âRIAS:
${subSubjects ? `- Use as sub-mat√©rias fornecidas para criar t√≥picos mais espec√≠ficos e detalhados
- Organize o cronograma considerando a progress√£o l√≥gica das sub-mat√©rias
- Inclua revis√µes e conex√µes entre as sub-mat√©rias relacionadas` : '- Foque nos t√≥picos gerais das mat√©rias principais'}

ESTRUTURA DO JSON:
{
  "title": "T√≠tulo do plano",
  "overview": "Descri√ß√£o geral",
  "schedule": [
    {
      "week": 1,
      "days": [
        {
          "day": "Segunda-feira",
          "subjects": ["Mat√©ria1", "Mat√©ria2"],
          "topics": ["T√≥pico 1", "T√≥pico 2", "T√≥pico 3"],
          "hours": 4,
          "completed": false,
          "completedTopics": [],
          "notes": ""
        }
      ]
    }
  ],
  "tips": [
    "Dica 1",
    "Dica 2",
    "Dica 3"
  ]
}

IMPORTANTE:
- Distribua as mat√©rias de forma equilibrada
- Crie t√≥picos espec√≠ficos e acion√°veis
- Considere o n√≠vel de dificuldade
- Inclua revis√µes e pausas
- Seja realista com o tempo dispon√≠vel
- Use linguagem motivadora

Retorne APENAS o JSON v√°lido:`;

    try {
      console.log('üöÄ Chamando API da Anthropic para plano...');
      
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': ANTHROPIC_API_KEY,
          'anthropic-version': '2023-06-01',
        },
        body: JSON.stringify({
          model: 'claude-3-haiku-20240307',
          max_tokens: 4000,
          messages: [{ role: 'user', content: prompt }],
        }),
      });

      console.log(`üì° Resposta da API: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erro da API:', errorText);
        throw new Error(`API Error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log('‚úÖ Dados recebidos da Claude API');
      
      const content = data.content[0].text.trim();
      console.log('üìù Conte√∫do recebido:', content.substring(0, 200) + '...');
      
      // Limpa o conte√∫do para extrair apenas o JSON
      let jsonContent = content
        .replace(/```json\n?/g, '')
        .replace(/```\n?/g, '')
        .replace(/^[^{]*/, '') // Remove texto antes do primeiro {
        .replace(/[^}]*$/, '') // Remove texto depois do √∫ltimo }
        .trim();
      
      // Se ainda n√£o come√ßar com {, tenta encontrar o objeto
      if (!jsonContent.startsWith('{')) {
        const objectMatch = content.match(/\{[\s\S]*\}/);
        if (objectMatch) {
          jsonContent = objectMatch[0];
        }
      }
      
      console.log('üîç JSON extra√≠do:', jsonContent.substring(0, 100) + '...');
      
      // Tentar corrigir JSON malformado
      let studyPlan;
      
      try {
        // Primeira tentativa: parse direto
        studyPlan = JSON.parse(jsonContent);
        console.log('‚úÖ JSON parseado com sucesso na primeira tentativa');
      } catch (firstError) {
        console.log('‚ö†Ô∏è Primeira tentativa falhou, tentando corrigir JSON...');
        
        try {
          // Segunda tentativa: corrigir JSON malformado
          let fixedJson = jsonContent;
          
          // Corrigir v√≠rgulas faltantes em arrays
          fixedJson = fixedJson.replace(/(\w+)\s*\n\s*(\w+)/g, '$1,\n$2');
          
          // Corrigir v√≠rgulas faltantes em objetos
          fixedJson = fixedJson.replace(/(\w+)\s*\n\s*"(\w+)":/g, '$1,\n"$2":');
          
          // Corrigir v√≠rgulas antes de fechamento de array
          fixedJson = fixedJson.replace(/(\w+)\s*\n\s*\]/g, '$1\n]');
          
          // Corrigir v√≠rgulas antes de fechamento de objeto
          fixedJson = fixedJson.replace(/(\w+)\s*\n\s*\}/g, '$1\n}');
          
          console.log('üîß JSON corrigido:', fixedJson.substring(0, 200) + '...');
          
          studyPlan = JSON.parse(fixedJson);
          console.log('‚úÖ JSON parseado com sucesso ap√≥s corre√ß√£o');
        } catch (secondError) {
          console.log('‚ùå Segunda tentativa falhou, criando estrutura b√°sica...');
          
          // Terceira tentativa: criar estrutura b√°sica
          studyPlan = {
            title: "Plano de Estudos Personalizado",
            overview: "Plano de estudos criado com base nas suas necessidades",
            schedule: [
              {
                week: 1,
                days: [
                  {
                    day: "Segunda-feira",
                    subjects: ["Matem√°tica"],
                    topics: ["Revis√£o geral", "Exerc√≠cios pr√°ticos"],
                    hours: 2,
                    completed: false,
                    completedTopics: [],
                    notes: ""
                  }
                ]
              }
            ],
            tips: [
              "Mantenha um cronograma regular de estudos",
              "Fa√ßa pausas regulares para descansar",
              "Revise o conte√∫do regularmente"
            ]
          };
          
          console.log('‚úÖ Estrutura b√°sica criada como fallback');
        }
      }
      
      // Valida se tem a estrutura b√°sica
      if (!studyPlan.title || !studyPlan.schedule || !Array.isArray(studyPlan.schedule)) {
        throw new Error('Estrutura do plano inv√°lida');
      }

      console.log('üéâ Plano de estudo gerado com sucesso!');
      res.json(studyPlan);
    } catch (error) {
      console.error('‚ùå Erro no servidor:', error);
      res.status(500).json({ error: error.message });
    }
  } catch (error) {
    console.error('‚ùå Erro geral no endpoint:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para gerar flashcards
app.post('/api/generate-flashcards', async (req, res) => {
  try {
    console.log('üì® Requisi√ß√£o recebida:', req.body);
    const { theme, numberOfCards } = req.body;
    const ANTHROPIC_API_KEY = process.env.VITE_ANTHROPIC_API_KEY;

    console.log(`üîç Gerando ${numberOfCards} flashcards sobre: ${theme}`);
    console.log(`üîë API Key configurada: ${ANTHROPIC_API_KEY ? 'Sim' : 'N√£o'}`);

    if (!ANTHROPIC_API_KEY) {
      console.error('‚ùå API Key n√£o configurada');
      return res.status(500).json({ error: 'API Key n√£o configurada' });
    }

  const prompt = `Voc√™ √© um especialista em educa√ß√£o. Gere exatamente ${numberOfCards} flashcards sobre o tema: "${theme}".

IMPORTANTE:
- Cada flashcard deve ter uma pergunta espec√≠fica e uma resposta completa e CORRETA
- As respostas devem ser factualmente precisas e educativas
- Varie os tipos de perguntas
- Use linguagem clara para estudantes brasileiros

Retorne APENAS um array JSON:
[{"question": "...", "answer": "..."}]`;

  try {
    console.log('üöÄ Chamando API da Anthropic...');
    
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307',
        max_tokens: 2000,
        messages: [{ role: 'user', content: prompt }],
      }),
    });

    console.log(`üì° Resposta da API: ${response.status} ${response.statusText}`);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Erro da API:', errorText);
      throw new Error(`API Error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log('‚úÖ Dados recebidos da Claude API');
    
    const content = data.content[0].text.trim();
    console.log('üìù Conte√∫do recebido:', content.substring(0, 200) + '...');
    
    // Limpa o conte√∫do para extrair apenas o JSON
    let jsonContent = content
      .replace(/```json\n?/g, '')
      .replace(/```\n?/g, '')
      .replace(/^[^{]*/, '') // Remove texto antes do primeiro {
      .replace(/[^}]*$/, '') // Remove texto depois do √∫ltimo }
      .trim();
    
    // Se ainda n√£o come√ßar com [, tenta encontrar o array
    if (!jsonContent.startsWith('[')) {
      const arrayMatch = content.match(/\[[\s\S]*\]/);
      if (arrayMatch) {
        jsonContent = arrayMatch[0];
      }
    }
    
    console.log('üîç JSON extra√≠do:', jsonContent.substring(0, 100) + '...');
    
    const flashcards = JSON.parse(jsonContent);

    console.log(`üéâ ${flashcards.length} flashcards gerados com sucesso!`);
    res.json({ flashcards });
  } catch (error) {
    console.error('‚ùå Erro no servidor:', error);
    res.status(500).json({ error: error.message });
  }
  } catch (error) {
    console.error('‚ùå Erro geral no endpoint:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint para gerar quiz
app.post('/api/generate-quiz', async (req, res) => {
  try {
    console.log('üì® Requisi√ß√£o de quiz recebida:', req.body);
    const { topic, numberOfQuestions = 10 } = req.body;
    const ANTHROPIC_API_KEY = process.env.VITE_ANTHROPIC_API_KEY;

    console.log(`üîç Gerando quiz de ${numberOfQuestions} quest√µes sobre: ${topic}`);
    console.log(`üîë API Key configurada: ${ANTHROPIC_API_KEY ? 'Sim' : 'N√£o'}`);

    if (!ANTHROPIC_API_KEY) {
      console.error('‚ùå API Key n√£o configurada');
      return res.status(500).json({ error: 'API Key n√£o configurada' });
    }

    const prompt = `Crie ${numberOfQuestions} quest√µes de m√∫ltipla escolha sobre o t√≥pico "${topic}".

INSTRU√á√ïES:
- Crie exatamente ${numberOfQuestions} quest√µes
- Cada quest√£o deve ter 4 alternativas (A, B, C, D)
- Uma alternativa deve ser a resposta correta
- As quest√µes devem ser claras e espec√≠ficas sobre "${topic}"
- Use linguagem adequada para estudantes brasileiros
- Varie o n√≠vel de dificuldade das quest√µes
- Inclua uma explica√ß√£o educativa para cada quest√£o

IMPORTANTE: Responda APENAS com o JSON, sem texto adicional.

JSON:
{
  "quiz": [
    {
      "question": "Pergunta espec√≠fica sobre ${topic}",
      "options": ["A) Primeira alternativa", "B) Segunda alternativa", "C) Terceira alternativa", "D) Quarta alternativa"],
      "correct": 1,
      "explanation": "Explica√ß√£o detalhada do porqu√™ a resposta est√° correta"
    }
  ]
}

NOTA: O campo "correct" deve ser o √≠ndice da alternativa correta (0=A, 1=B, 2=C, 3=D)`;

    try {
      console.log('üöÄ Chamando API da Anthropic para quiz...');
      
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': ANTHROPIC_API_KEY,
          'anthropic-version': '2023-06-01',
        },
        body: JSON.stringify({
          model: 'claude-3-haiku-20240307',
          max_tokens: 4000,
          messages: [{ role: 'user', content: prompt }],
        }),
      });

      console.log(`üì° Resposta da API: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erro da API:', errorText);
        throw new Error(`API Error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log('‚úÖ Dados recebidos da Claude API');
      
      const content = data.content[0].text.trim();
      console.log('üìù Conte√∫do recebido:', content.substring(0, 200) + '...');
      
      // Limpa o conte√∫do para extrair apenas o JSON
      let jsonContent = content
        .replace(/```json\n?/g, '')
        .replace(/```\n?/g, '')
        .replace(/^[^{]*/, '') // Remove texto antes do primeiro {
        .replace(/[^}]*$/, '') // Remove texto depois do √∫ltimo }
        .trim();
      
      // Se ainda n√£o come√ßar com {, tenta encontrar o objeto
      if (!jsonContent.startsWith('{')) {
        const objectMatch = content.match(/\{[\s\S]*\}/);
        if (objectMatch) {
          jsonContent = objectMatch[0];
        }
      }
      
      console.log('üîç JSON extra√≠do:', jsonContent.substring(0, 100) + '...');
      
      // Tentar corrigir JSON malformado
      let quiz;
      
      try {
        // Primeira tentativa: parse direto
        quiz = JSON.parse(jsonContent);
        console.log('‚úÖ JSON parseado com sucesso na primeira tentativa');
      } catch (firstError) {
        console.log('‚ö†Ô∏è Primeira tentativa falhou, tentando corrigir JSON...');
        
        try {
          // Segunda tentativa: corrigir JSON malformado
          let fixedJson = jsonContent;
          
          // Corrigir v√≠rgulas faltantes em arrays
          fixedJson = fixedJson.replace(/(\w+)\s*\n\s*(\w+)/g, '$1,\n$2');
          
          // Corrigir v√≠rgulas faltantes em objetos
          fixedJson = fixedJson.replace(/(\w+)\s*\n\s*"(\w+)":/g, '$1,\n"$2":');
          
          // Corrigir v√≠rgulas antes de fechamento de array
          fixedJson = fixedJson.replace(/(\w+)\s*\n\s*\]/g, '$1\n]');
          
          // Corrigir v√≠rgulas antes de fechamento de objeto
          fixedJson = fixedJson.replace(/(\w+)\s*\n\s*\}/g, '$1\n}');
          
          console.log('üîß JSON corrigido:', fixedJson.substring(0, 200) + '...');
          
          quiz = JSON.parse(fixedJson);
          console.log('‚úÖ JSON parseado com sucesso ap√≥s corre√ß√£o');
        } catch (secondError) {
          console.log('‚ùå Segunda tentativa falhou, criando estrutura b√°sica...');
          
          // Terceira tentativa: criar estrutura b√°sica
          quiz = {
            quiz: Array.from({ length: numberOfQuestions }, (_, i) => ({
              question: `Quest√£o ${i + 1} sobre ${topic}`,
              options: [
                `A) Alternativa A da quest√£o ${i + 1}`,
                `B) Alternativa B da quest√£o ${i + 1}`,
                `C) Alternativa C da quest√£o ${i + 1}`,
                `D) Alternativa D da quest√£o ${i + 1}`
              ],
              correct: 1,
              explanation: `Explica√ß√£o para a quest√£o ${i + 1} sobre ${topic}`
            }))
          };
          
          console.log('‚úÖ Estrutura b√°sica criada como fallback');
        }
      }
      
      // Valida se tem a estrutura b√°sica
      if (!quiz.quiz || !Array.isArray(quiz.quiz)) {
        throw new Error('Estrutura do quiz inv√°lida');
      }

      // Validar cada quest√£o
      quiz.quiz = quiz.quiz.map((question, index) => {
        if (!question.question || !question.options || !Array.isArray(question.options) || question.options.length !== 4) {
          throw new Error(`Quest√£o ${index + 1} tem estrutura inv√°lida`);
        }
        if (typeof question.correct !== 'number' || question.correct < 0 || question.correct > 3) {
          throw new Error(`Quest√£o ${index + 1} tem √≠ndice de resposta correta inv√°lido`);
        }
        return question;
      });

      console.log(`üéâ Quiz de ${quiz.quiz.length} quest√µes gerado com sucesso!`);
      res.json(quiz);
    } catch (error) {
      console.error('‚ùå Erro no servidor:', error);
      res.status(500).json({ error: error.message });
    }
  } catch (error) {
    console.error('‚ùå Erro geral no endpoint:', error);
    res.status(500).json({ error: error.message });
  }
});

// Servir arquivos est√°ticos em produ√ß√£o
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, 'dist')));
  
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'dist', 'index.html'));
  });
}

app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando em http://localhost:${PORT}`);
  console.log(`üì° Endpoint: http://localhost:${PORT}/api/generate-flashcards`);
});
